#include "codegen.h"
#include <algorithm>
#include <cctype>

namespace hybrid {

std::string RustCodeGenerator::generate(const IR& ir) {
    output_.str("");
    output_.clear();

    // Generate file header
    writeLine("// Auto-generated Rust code from C++ source");
    writeLine("// Generated by Hybrid Transpiler");
    writeLine("");

    // Generate classes/structs
    for (const auto& class_decl : ir.getClasses()) {
        generateClass(class_decl);
        writeLine("");
    }

    // Generate standalone functions
    for (const auto& func : ir.getFunctions()) {
        generateFunction(func);
        writeLine("");
    }

    // Generate global variables (as constants or static)
    for (const auto& var : ir.getGlobalVariables()) {
        generateVariable(var);
    }

    return output_.str();
}

void RustCodeGenerator::generateClass(const ClassDecl& class_decl) {
    // Generate struct definition with generics
    std::string struct_decl = "pub struct " + sanitizeName(class_decl.name);

    // Add generic parameters if template
    if (class_decl.is_template && !class_decl.template_parameters.empty()) {
        struct_decl += convertTemplateParametersToRust(class_decl.template_parameters);
    }

    struct_decl += " {";
    writeLine(struct_decl);
    indent();

    for (const auto& field : class_decl.fields) {
        std::string visibility = "pub "; // Simplified - would need proper access control
        std::string field_name = sanitizeName(field.name);
        std::string field_type = convertType(field.type);

        writeLine(visibility + field_name + ": " + field_type + ",");
    }

    dedent();
    writeLine("}");
    writeLine("");

    // Generate impl block for methods
    if (!class_decl.methods.empty()) {
        std::string impl_decl = "impl";

        // Add generic parameters
        if (class_decl.is_template && !class_decl.template_parameters.empty()) {
            impl_decl += convertTemplateParametersToRust(class_decl.template_parameters);
        }

        impl_decl += " " + sanitizeName(class_decl.name);

        // Add generic type arguments
        if (class_decl.is_template && !class_decl.template_parameters.empty()) {
            impl_decl += convertTemplateArgsToRust(class_decl.template_parameters);
        }

        impl_decl += " {";
        writeLine(impl_decl);
        indent();

        for (const auto& method : class_decl.methods) {
            generateFunction(method);
            writeLine("");
        }

        dedent();
        writeLine("}");
    }

    // Generate trait implementations for base classes
    if (!class_decl.base_classes.empty()) {
        writeLine("");
        writeLine("// Note: C++ inheritance converted to trait implementation");
        for (const auto& base : class_decl.base_classes) {
            writeLine("// TODO: Implement trait for base class: " + base);
        }
    }
}

void RustCodeGenerator::generateFunction(const Function& func) {
    std::stringstream sig;

    // Constructor becomes 'new' in Rust
    if (func.is_constructor) {
        sig << "pub fn new";
    } else {
        sig << "pub fn " << sanitizeName(func.name);
    }

    // Add generic parameters for template functions
    if (func.is_template && !func.template_parameters.empty()) {
        sig << convertTemplateParametersToRust(func.template_parameters);
    }

    sig << "(";

    // Add self parameter for methods
    if (!func.is_static && !func.is_constructor) {
        if (func.is_const) {
            sig << "&self";
        } else {
            sig << "&mut self";
        }

        if (!func.parameters.empty()) {
            sig << ", ";
        }
    }

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << ": " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type - wrap in Result if function may throw
    if (func.is_constructor) {
        sig << " -> Self";
    } else if (func.may_throw) {
        // Function may throw - convert to Result type
        if (func.return_type->kind != TypeKind::Void) {
            sig << " -> Result<" << convertType(func.return_type)
                << ", Box<dyn std::error::Error>>";
        } else {
            sig << " -> Result<(), Box<dyn std::error::Error>>";
        }
    } else if (func.return_type->kind != TypeKind::Void) {
        sig << " -> " << convertType(func.return_type);
    }

    writeLine(sig.str() + " {");
    indent();

    // Function body with exception handling conversion
    if (!func.try_catch_blocks.empty()) {
        // Convert try-catch blocks to Result pattern
        generateTryCatchAsResult(func);
    } else if (!func.body.empty()) {
        // Regular function body
        if (func.may_throw) {
            writeLine("// Function may throw - wrap result in Ok()");
        }
        writeLine("// TODO: Implement function body");
        writeLine(func.body);

        if (func.may_throw && func.return_type->kind != TypeKind::Void) {
            writeLine("// Ok(result)");
        } else if (func.may_throw) {
            writeLine("Ok(())");
        }
    } else {
        if (func.may_throw) {
            writeLine("Ok(())");
        } else {
            writeLine("todo!()");
        }
    }

    dedent();
    writeLine("}");
}

void RustCodeGenerator::generateTryCatchAsResult(const Function& func) {
    // Convert C++ try-catch to Rust Result pattern
    writeLine("// Converted from C++ try-catch block");

    for (const auto& block : func.try_catch_blocks) {
        // Generate the try body as a closure or inline code
        writeLine("(|| -> Result<_, Box<dyn std::error::Error>> {");
        indent();

        // Generate try block body
        writeLine("// Try block:");
        if (!block.try_body.empty()) {
            writeLine(block.try_body);
        }

        // If try succeeds, return Ok
        if (func.return_type->kind != TypeKind::Void) {
            writeLine("Ok(result)  // TODO: actual return value");
        } else {
            writeLine("Ok(())");
        }

        dedent();
        writeLine("})()");

        // Generate match for error handling (equivalent to catch)
        if (!block.catch_clauses.empty()) {
            writeLine(".or_else(|err| {");
            indent();

            for (const auto& catch_clause : block.catch_clauses) {
                writeLine("// Catch " + catch_clause.exception_type);

                if (catch_clause.exception_type == "...") {
                    writeLine("// Catch-all handler");
                } else {
                    writeLine("// Handle specific exception type: " + catch_clause.exception_type);
                }

                if (!catch_clause.handler_body.empty()) {
                    writeLine(catch_clause.handler_body);
                }
            }

            if (func.return_type->kind != TypeKind::Void) {
                writeLine("Ok(default_value)  // TODO: error recovery value");
            } else {
                writeLine("Ok(())");
            }

            dedent();
            writeLine("})");
        }
    }
}

void RustCodeGenerator::generateVariable(const Variable& var) {
    std::string modifier = var.is_const ? "const" : "static";
    std::string name = sanitizeName(var.name).c_str();
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    std::string type = convertType(var.type);

    std::stringstream line;
    line << modifier << " " << name << ": " << type;

    if (!var.initializer.empty()) {
        line << " = " << var.initializer;
    }

    line << ";";
    writeLine(line.str());
}

std::string RustCodeGenerator::convertType(const std::shared_ptr<Type>& type) {
    if (!type) return "()";

    switch (type->kind) {
        case TypeKind::Void:
            return "()";

        case TypeKind::Bool:
            return "bool";

        case TypeKind::Integer:
            // Map C++ integer types to Rust
            if (type->name == "int" || type->name == "int32_t") return "i32";
            if (type->name == "long" || type->name == "int64_t") return "i64";
            if (type->name == "short" || type->name == "int16_t") return "i16";
            if (type->name == "char" || type->name == "int8_t") return "i8";
            if (type->name == "unsigned int" || type->name == "uint32_t") return "u32";
            if (type->name == "unsigned long" || type->name == "uint64_t") return "u64";
            if (type->name == "unsigned short" || type->name == "uint16_t") return "u16";
            if (type->name == "unsigned char" || type->name == "uint8_t") return "u8";
            if (type->name == "size_t") return "usize";
            return "i32"; // default

        case TypeKind::Float:
            if (type->name == "float") return "f32";
            if (type->name == "double") return "f64";
            return "f64"; // default

        case TypeKind::Pointer:
            return convertSmartPointer(type);

        case TypeKind::Reference:
            if (type->is_const) {
                return "&" + convertType(type->element_type);
            } else {
                return "&mut " + convertType(type->element_type);
            }

        case TypeKind::Array:
            return "[" + convertType(type->element_type) + "; " +
                   std::to_string(type->size_bytes / type->element_type->size_bytes) + "]";

        // STL Container types
        case TypeKind::StdVector:
            if (!type->template_args.empty()) {
                return "Vec<" + convertType(type->template_args[0]) + ">";
            }
            return "Vec<()>";

        case TypeKind::StdList:
            if (!type->template_args.empty()) {
                return "std::collections::LinkedList<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::LinkedList<()>";

        case TypeKind::StdDeque:
            if (!type->template_args.empty()) {
                return "std::collections::VecDeque<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::VecDeque<()>";

        case TypeKind::StdMap:
            if (type->template_args.size() >= 2) {
                return "std::collections::BTreeMap<" +
                       convertType(type->template_args[0]) + ", " +
                       convertType(type->template_args[1]) + ">";
            }
            return "std::collections::BTreeMap<(), ()>";

        case TypeKind::StdUnorderedMap:
            if (type->template_args.size() >= 2) {
                return "std::collections::HashMap<" +
                       convertType(type->template_args[0]) + ", " +
                       convertType(type->template_args[1]) + ">";
            }
            return "std::collections::HashMap<(), ()>";

        case TypeKind::StdSet:
            if (!type->template_args.empty()) {
                return "std::collections::BTreeSet<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::BTreeSet<()>";

        case TypeKind::StdUnorderedSet:
            if (!type->template_args.empty()) {
                return "std::collections::HashSet<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::HashSet<()>";

        case TypeKind::StdString:
            return "String";

        case TypeKind::StdPair:
            if (type->template_args.size() >= 2) {
                return "(" + convertType(type->template_args[0]) + ", " +
                       convertType(type->template_args[1]) + ")";
            }
            return "((), ())";

        case TypeKind::StdOptional:
            if (!type->template_args.empty()) {
                return "Option<" + convertType(type->template_args[0]) + ">";
            }
            return "Option<()>";

        case TypeKind::Struct:
        case TypeKind::Class:
            return sanitizeName(type->name);

        default:
            return "/* Unknown type: " + type->name + " */";
    }
}

std::string RustCodeGenerator::convertSmartPointer(const std::shared_ptr<Type>& type) {
    // Check if this is a smart pointer pattern
    if (type->name.find("unique_ptr") != std::string::npos) {
        return "Box<" + convertType(type->element_type) + ">";
    }
    if (type->name.find("shared_ptr") != std::string::npos) {
        return "Rc<" + convertType(type->element_type) + ">";
    }
    if (type->name.find("weak_ptr") != std::string::npos) {
        return "Weak<" + convertType(type->element_type) + ">";
    }

    // Raw pointer - use unsafe raw pointer in Rust
    if (type->is_const) {
        return "*const " + convertType(type->element_type);
    } else {
        return "*mut " + convertType(type->element_type);
    }
}

std::string RustCodeGenerator::sanitizeName(const std::string& name) {
    // Convert C++ naming conventions to Rust snake_case
    std::string result;
    bool prev_upper = false;

    for (size_t i = 0; i < name.size(); ++i) {
        char c = name[i];

        if (std::isupper(c) && i > 0 && !prev_upper) {
            result += '_';
            result += std::tolower(c);
            prev_upper = true;
        } else {
            result += std::tolower(c);
            prev_upper = std::isupper(c);
        }
    }

    // Handle Rust keywords
    static const std::vector<std::string> keywords = {
        "as", "break", "const", "continue", "crate", "else", "enum", "extern",
        "false", "fn", "for", "if", "impl", "in", "let", "loop", "match",
        "mod", "move", "mut", "pub", "ref", "return", "self", "Self",
        "static", "struct", "super", "trait", "true", "type", "unsafe",
        "use", "where", "while"
    };

    if (std::find(keywords.begin(), keywords.end(), result) != keywords.end()) {
        result = "r#" + result;
    }

    return result;
}

std::string RustCodeGenerator::convertTemplateParametersToRust(const std::vector<TemplateParameter>& params) {
    if (params.empty()) {
        return "";
    }

    std::stringstream ss;
    ss << "<";

    bool first = true;
    for (const auto& param : params) {
        if (!first) ss << ", ";
        first = false;

        if (param.kind == TemplateParameter::Type) {
            ss << param.name;

            // Add trait bounds if constraints exist
            if (!param.constraints.empty()) {
                ss << ": ";
                for (size_t i = 0; i < param.constraints.size(); ++i) {
                    if (i > 0) ss << " + ";
                    ss << param.constraints[i];
                }
            }
        } else if (param.kind == TemplateParameter::NonType) {
            // Rust const generics
            ss << "const " << param.name << ": ";
            if (param.param_type) {
                ss << convertType(param.param_type);
            } else {
                ss << "usize";
            }
        }
    }

    ss << ">";
    return ss.str();
}

std::string RustCodeGenerator::convertTemplateArgsToRust(const std::vector<TemplateParameter>& params) {
    if (params.empty()) {
        return "";
    }

    std::stringstream ss;
    ss << "<";

    bool first = true;
    for (const auto& param : params) {
        if (!first) ss << ", ";
        first = false;

        if (param.kind == TemplateParameter::Type) {
            ss << param.name;
        } else if (param.kind == TemplateParameter::NonType) {
            ss << param.name;
        }
    }

    ss << ">";
    return ss.str();
}

} // namespace hybrid
