#include "codegen.h"
#include <algorithm>
#include <cctype>

namespace hybrid {

std::string RustCodeGenerator::generate(const IR& ir) {
    output_.str("");
    output_.clear();

    // Generate file header
    writeLine("// Auto-generated Rust code from C++ source");
    writeLine("// Generated by Hybrid Transpiler");
    writeLine("");

    // Generate classes/structs
    for (const auto& class_decl : ir.getClasses()) {
        generateClass(class_decl);
        writeLine("");
    }

    // Generate standalone functions
    for (const auto& func : ir.getFunctions()) {
        generateFunction(func);
        writeLine("");
    }

    // Generate global variables (as constants or static)
    for (const auto& var : ir.getGlobalVariables()) {
        generateVariable(var);
    }

    return output_.str();
}

void RustCodeGenerator::generateClass(const ClassDecl& class_decl) {
    // Generate struct definition with generics
    std::string struct_decl = "pub struct " + sanitizeName(class_decl.name);

    // Add generic parameters if template
    if (class_decl.is_template && !class_decl.template_parameters.empty()) {
        struct_decl += convertTemplateParametersToRust(class_decl.template_parameters);
    }

    struct_decl += " {";
    writeLine(struct_decl);
    indent();

    for (const auto& field : class_decl.fields) {
        std::string visibility = "pub "; // Simplified - would need proper access control
        std::string field_name = sanitizeName(field.name);
        std::string field_type = convertType(field.type);

        writeLine(visibility + field_name + ": " + field_type + ",");
    }

    dedent();
    writeLine("}");
    writeLine("");

    // Generate impl block for methods
    if (!class_decl.methods.empty()) {
        std::string impl_decl = "impl";

        // Add generic parameters
        if (class_decl.is_template && !class_decl.template_parameters.empty()) {
            impl_decl += convertTemplateParametersToRust(class_decl.template_parameters);
        }

        impl_decl += " " + sanitizeName(class_decl.name);

        // Add generic type arguments
        if (class_decl.is_template && !class_decl.template_parameters.empty()) {
            impl_decl += convertTemplateArgsToRust(class_decl.template_parameters);
        }

        impl_decl += " {";
        writeLine(impl_decl);
        indent();

        for (const auto& method : class_decl.methods) {
            generateFunction(method, true);  // true = is_method
            writeLine("");
        }

        dedent();
        writeLine("}");
    }

    // Generate trait implementations for base classes
    if (!class_decl.base_classes.empty()) {
        writeLine("");
        generateTraitImplementations(class_decl);
    }
}

void RustCodeGenerator::generateFunction(const Function& func, bool is_method) {
    // If function is async or coroutine, use async generation
    if (func.is_async || func.coroutine_info.is_coroutine) {
        generateAsyncFunction(func);
        return;
    }

    std::stringstream sig;

    // Constructor becomes 'new' in Rust
    if (func.is_constructor) {
        sig << "pub fn new";
    } else {
        sig << "pub fn " << sanitizeName(func.name);
    }

    // Add generic parameters for template functions
    if (func.is_template && !func.template_parameters.empty()) {
        sig << convertTemplateParametersToRust(func.template_parameters);
    }

    sig << "(";

    // Add self parameter for methods (not standalone functions)
    if (is_method && !func.is_static && !func.is_constructor) {
        if (func.is_const) {
            sig << "&self";
        } else {
            sig << "&mut self";
        }

        if (!func.parameters.empty()) {
            sig << ", ";
        }
    }

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << ": " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type - wrap in Result if function may throw
    if (func.is_constructor) {
        sig << " -> Self";
    } else if (func.may_throw) {
        // Function may throw - convert to Result type
        if (func.return_type->kind != TypeKind::Void) {
            sig << " -> Result<" << convertType(func.return_type)
                << ", Box<dyn std::error::Error>>";
        } else {
            sig << " -> Result<(), Box<dyn std::error::Error>>";
        }
    } else if (func.return_type->kind != TypeKind::Void) {
        sig << " -> " << convertType(func.return_type);
    }

    writeLine(sig.str() + " {");
    indent();

    // Function body with threading conversion
    if (func.uses_threading) {
        generateThreadingCode(func);
    }
    // Function body with exception handling conversion
    else if (!func.try_catch_blocks.empty()) {
        // Convert try-catch blocks to Result pattern
        generateTryCatchAsResult(func);
    } else if (!func.body.empty()) {
        // Regular function body
        if (func.may_throw) {
            writeLine("// Function may throw - wrap result in Ok()");
        }
        writeLine("// TODO: Implement function body");
        writeLine(func.body);

        if (func.may_throw && func.return_type->kind != TypeKind::Void) {
            writeLine("// Ok(result)");
        } else if (func.may_throw) {
            writeLine("Ok(())");
        }
    } else {
        if (func.may_throw) {
            writeLine("Ok(())");
        } else {
            writeLine("todo!()");
        }
    }

    dedent();
    writeLine("}");
}

void RustCodeGenerator::generateTryCatchAsResult(const Function& func) {
    // Convert C++ try-catch to Rust Result pattern
    writeLine("// Converted from C++ try-catch block");

    for (const auto& block : func.try_catch_blocks) {
        // Generate the try body as a closure or inline code
        writeLine("(|| -> Result<_, Box<dyn std::error::Error>> {");
        indent();

        // Generate try block body
        writeLine("// Try block:");
        if (!block.try_body.empty()) {
            writeLine(block.try_body);
        }

        // If try succeeds, return Ok
        if (func.return_type->kind != TypeKind::Void) {
            writeLine("Ok(result)  // TODO: actual return value");
        } else {
            writeLine("Ok(())");
        }

        dedent();
        writeLine("})()");

        // Generate match for error handling (equivalent to catch)
        if (!block.catch_clauses.empty()) {
            writeLine(".or_else(|err| {");
            indent();

            for (const auto& catch_clause : block.catch_clauses) {
                writeLine("// Catch " + catch_clause.exception_type);

                if (catch_clause.exception_type == "...") {
                    writeLine("// Catch-all handler");
                } else {
                    writeLine("// Handle specific exception type: " + catch_clause.exception_type);
                }

                if (!catch_clause.handler_body.empty()) {
                    writeLine(catch_clause.handler_body);
                }
            }

            if (func.return_type->kind != TypeKind::Void) {
                writeLine("Ok(default_value)  // TODO: error recovery value");
            } else {
                writeLine("Ok(())");
            }

            dedent();
            writeLine("})");
        }
    }
}

void RustCodeGenerator::generateVariable(const Variable& var) {
    std::string modifier = var.is_const ? "const" : "static";
    std::string name = sanitizeName(var.name).c_str();
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    std::string type = convertType(var.type);

    std::stringstream line;
    line << modifier << " " << name << ": " << type;

    if (!var.initializer.empty()) {
        line << " = " << var.initializer;
    }

    line << ";";
    writeLine(line.str());
}

std::string RustCodeGenerator::convertType(const std::shared_ptr<Type>& type) {
    if (!type) return "()";

    switch (type->kind) {
        case TypeKind::Void:
            return "()";

        case TypeKind::Bool:
            return "bool";

        case TypeKind::Integer:
            // Map C++ integer types to Rust
            if (type->name == "int" || type->name == "int32_t") return "i32";
            if (type->name == "long" || type->name == "int64_t") return "i64";
            if (type->name == "short" || type->name == "int16_t") return "i16";
            if (type->name == "char" || type->name == "int8_t") return "i8";
            if (type->name == "unsigned int" || type->name == "uint32_t") return "u32";
            if (type->name == "unsigned long" || type->name == "uint64_t") return "u64";
            if (type->name == "unsigned short" || type->name == "uint16_t") return "u16";
            if (type->name == "unsigned char" || type->name == "uint8_t") return "u8";
            if (type->name == "size_t") return "usize";
            return "i32"; // default

        case TypeKind::Float:
            if (type->name == "float") return "f32";
            if (type->name == "double") return "f64";
            return "f64"; // default

        case TypeKind::Pointer:
            return convertSmartPointer(type);

        case TypeKind::Reference:
            if (type->is_const) {
                return "&" + convertType(type->element_type);
            } else {
                return "&mut " + convertType(type->element_type);
            }

        case TypeKind::Array:
            return "[" + convertType(type->element_type) + "; " +
                   std::to_string(type->size_bytes / type->element_type->size_bytes) + "]";

        // STL Container types
        case TypeKind::StdVector:
            if (!type->template_args.empty()) {
                return "Vec<" + convertType(type->template_args[0]) + ">";
            }
            return "Vec<()>";

        case TypeKind::StdList:
            if (!type->template_args.empty()) {
                return "std::collections::LinkedList<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::LinkedList<()>";

        case TypeKind::StdDeque:
            if (!type->template_args.empty()) {
                return "std::collections::VecDeque<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::VecDeque<()>";

        case TypeKind::StdMap:
            if (type->template_args.size() >= 2) {
                return "std::collections::BTreeMap<" +
                       convertType(type->template_args[0]) + ", " +
                       convertType(type->template_args[1]) + ">";
            }
            return "std::collections::BTreeMap<(), ()>";

        case TypeKind::StdUnorderedMap:
            if (type->template_args.size() >= 2) {
                return "std::collections::HashMap<" +
                       convertType(type->template_args[0]) + ", " +
                       convertType(type->template_args[1]) + ">";
            }
            return "std::collections::HashMap<(), ()>";

        case TypeKind::StdSet:
            if (!type->template_args.empty()) {
                return "std::collections::BTreeSet<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::BTreeSet<()>";

        case TypeKind::StdUnorderedSet:
            if (!type->template_args.empty()) {
                return "std::collections::HashSet<" + convertType(type->template_args[0]) + ">";
            }
            return "std::collections::HashSet<()>";

        case TypeKind::StdString:
            return "String";

        case TypeKind::StdPair:
            if (type->template_args.size() >= 2) {
                return "(" + convertType(type->template_args[0]) + ", " +
                       convertType(type->template_args[1]) + ")";
            }
            return "((), ())";

        case TypeKind::StdOptional:
            if (!type->template_args.empty()) {
                return "Option<" + convertType(type->template_args[0]) + ">";
            }
            return "Option<()>";

        // Threading types
        case TypeKind::StdThread:
            return "std::thread::JoinHandle<()>";

        case TypeKind::StdMutex:
            if (!type->template_args.empty()) {
                return "std::sync::Mutex<" + convertType(type->template_args[0]) + ">";
            }
            return "std::sync::Mutex<()>";

        case TypeKind::StdRecursiveMutex:
            if (!type->template_args.empty()) {
                return "parking_lot::ReentrantMutex<" + convertType(type->template_args[0]) + ">";
            }
            return "parking_lot::ReentrantMutex<()>";

        case TypeKind::StdSharedMutex:
            if (!type->template_args.empty()) {
                return "std::sync::RwLock<" + convertType(type->template_args[0]) + ">";
            }
            return "std::sync::RwLock<()>";

        case TypeKind::StdConditionVariable:
            return "std::sync::Condvar";

        case TypeKind::StdAtomic:
            if (!type->template_args.empty()) {
                std::string inner_type = type->template_args[0]->name;
                if (inner_type == "int" || inner_type == "int32_t") return "std::sync::atomic::AtomicI32";
                if (inner_type == "long" || inner_type == "int64_t") return "std::sync::atomic::AtomicI64";
                if (inner_type == "unsigned int" || inner_type == "uint32_t") return "std::sync::atomic::AtomicU32";
                if (inner_type == "unsigned long" || inner_type == "uint64_t") return "std::sync::atomic::AtomicU64";
                if (inner_type == "bool") return "std::sync::atomic::AtomicBool";
                if (inner_type == "size_t") return "std::sync::atomic::AtomicUsize";
            }
            return "std::sync::atomic::AtomicUsize";

        case TypeKind::StdLockGuard:
        case TypeKind::StdUniqueLock:
            return "std::sync::MutexGuard";

        case TypeKind::StdSharedLock:
            return "std::sync::RwLockReadGuard";

        // Async/Coroutine types
        case TypeKind::StdFuture:
            if (!type->template_args.empty()) {
                return "impl std::future::Future<Output = " +
                       convertType(type->template_args[0]) + ">";
            }
            return "impl std::future::Future<Output = ()>";

        case TypeKind::StdPromise:
            if (!type->template_args.empty()) {
                return "futures::channel::oneshot::Sender<" +
                       convertType(type->template_args[0]) + ">";
            }
            return "futures::channel::oneshot::Sender<()>";

        case TypeKind::StdAsync:
        case TypeKind::Task:
            if (!type->template_args.empty()) {
                return "impl std::future::Future<Output = " +
                       convertType(type->template_args[0]) + ">";
            }
            return "impl std::future::Future<Output = ()>";

        case TypeKind::Coroutine:
            if (!type->template_args.empty()) {
                return "impl Stream<Item = " + convertType(type->template_args[0]) + ">";
            }
            return "impl Stream<Item = ()>";

        case TypeKind::Struct:
        case TypeKind::Class:
            return sanitizeName(type->name);

        default:
            return "/* Unknown type: " + type->name + " */";
    }
}

std::string RustCodeGenerator::convertSmartPointer(const std::shared_ptr<Type>& type) {
    // Check if this is a smart pointer pattern
    if (type->name.find("unique_ptr") != std::string::npos) {
        return "Box<" + convertType(type->element_type) + ">";
    }
    if (type->name.find("shared_ptr") != std::string::npos) {
        return "Rc<" + convertType(type->element_type) + ">";
    }
    if (type->name.find("weak_ptr") != std::string::npos) {
        return "Weak<" + convertType(type->element_type) + ">";
    }

    // Raw pointer - use unsafe raw pointer in Rust
    if (type->is_const) {
        return "*const " + convertType(type->element_type);
    } else {
        return "*mut " + convertType(type->element_type);
    }
}

std::string RustCodeGenerator::sanitizeName(const std::string& name) {
    // Convert C++ naming conventions to Rust snake_case
    std::string result;
    bool prev_upper = false;

    for (size_t i = 0; i < name.size(); ++i) {
        char c = name[i];

        if (std::isupper(c) && i > 0 && !prev_upper) {
            result += '_';
            result += std::tolower(c);
            prev_upper = true;
        } else {
            result += std::tolower(c);
            prev_upper = std::isupper(c);
        }
    }

    // Handle Rust keywords
    static const std::vector<std::string> keywords = {
        "as", "break", "const", "continue", "crate", "else", "enum", "extern",
        "false", "fn", "for", "if", "impl", "in", "let", "loop", "match",
        "mod", "move", "mut", "pub", "ref", "return", "self", "Self",
        "static", "struct", "super", "trait", "true", "type", "unsafe",
        "use", "where", "while"
    };

    if (std::find(keywords.begin(), keywords.end(), result) != keywords.end()) {
        result = "r#" + result;
    }

    return result;
}

std::string RustCodeGenerator::convertTemplateParametersToRust(const std::vector<TemplateParameter>& params) {
    if (params.empty()) {
        return "";
    }

    std::stringstream ss;
    ss << "<";

    bool first = true;
    for (const auto& param : params) {
        if (!first) ss << ", ";
        first = false;

        if (param.kind == TemplateParameter::TypeParam) {
            ss << param.name;

            // Add trait bounds if constraints exist
            if (!param.constraints.empty()) {
                ss << ": ";
                for (size_t i = 0; i < param.constraints.size(); ++i) {
                    if (i > 0) ss << " + ";
                    ss << param.constraints[i];
                }
            }
        } else if (param.kind == TemplateParameter::NonType) {
            // Rust const generics
            ss << "const " << param.name << ": ";
            if (param.param_type) {
                ss << convertType(param.param_type);
            } else {
                ss << "usize";
            }
        }
    }

    ss << ">";
    return ss.str();
}

std::string RustCodeGenerator::convertTemplateArgsToRust(const std::vector<TemplateParameter>& params) {
    if (params.empty()) {
        return "";
    }

    std::stringstream ss;
    ss << "<";

    bool first = true;
    for (const auto& param : params) {
        if (!first) ss << ", ";
        first = false;

        if (param.kind == TemplateParameter::TypeParam) {
            ss << param.name;
        } else if (param.kind == TemplateParameter::NonType) {
            ss << param.name;
        }
    }

    ss << ">";
    return ss.str();
}

void RustCodeGenerator::generateThreadingCode(const Function& func) {
    writeLine("// Threading code converted from C++");
    writeLine("");

    // Generate thread creation
    for (const auto& thread : func.threads_created) {
        generateThreadCreation(thread);
        writeLine("");
    }

    // Generate lock scopes
    for (const auto& lock : func.lock_scopes) {
        generateLockScope(lock);
        writeLine("");
    }

    // Generate atomic operations
    for (const auto& atomic : func.atomic_operations) {
        generateAtomicOperations(atomic);
        writeLine("");
    }

    // Generate condition variable operations
    for (const auto& cv : func.condition_variables) {
        generateConditionVariable(cv);
        writeLine("");
    }

    // Generate original function body
    if (!func.body.empty()) {
        writeLine("// Original function body:");
        writeLine(func.body);
    }

    // Join threads if they are joinable
    for (const auto& thread : func.threads_created) {
        if (thread.joinable && !thread.detached) {
            writeLine("");
            writeLine("// Wait for thread to complete");
            writeLine(thread.thread_var_name + ".join().unwrap();");
        }
    }
}

void RustCodeGenerator::generateThreadCreation(const ThreadInfo& thread) {
    std::stringstream ss;

    writeLine("// Thread: " + thread.thread_var_name);

    // Generate thread spawn
    ss << "let " << sanitizeName(thread.thread_var_name)
       << " = std::thread::spawn(move || {";

    writeLine(ss.str());
    indent();

    // Call the thread function with arguments
    ss.str("");
    ss << sanitizeName(thread.function_name) << "(";

    for (size_t i = 0; i < thread.arguments.size(); ++i) {
        ss << thread.arguments[i];
        if (i < thread.arguments.size() - 1) {
            ss << ", ";
        }
    }

    ss << ");";
    writeLine(ss.str());

    dedent();
    writeLine("});");

    if (thread.detached) {
        writeLine("// Note: Original thread was detached, but Rust threads are always joinable");
        writeLine("// Consider using std::mem::forget() if you want to detach");
    }
}

void RustCodeGenerator::generateLockScope(const LockInfo& lock) {
    std::stringstream ss;

    switch (lock.type) {
        case LockInfo::LockGuard:
            writeLine("// Lock guard (RAII lock)");
            ss << "let _" << sanitizeName(lock.lock_var_name)
               << " = " << sanitizeName(lock.mutex_name) << ".lock().unwrap();";
            writeLine(ss.str());
            break;

        case LockInfo::UniqueLock:
            writeLine("// Unique lock (RAII lock)");
            ss << "let mut " << sanitizeName(lock.lock_var_name)
               << " = " << sanitizeName(lock.mutex_name) << ".lock().unwrap();";
            writeLine(ss.str());
            break;

        case LockInfo::SharedLock:
            writeLine("// Shared lock (read lock)");
            ss << "let " << sanitizeName(lock.lock_var_name)
               << " = " << sanitizeName(lock.mutex_name) << ".read().unwrap();";
            writeLine(ss.str());
            break;

        default:
            writeLine("// Unknown lock type");
            break;
    }

    // Generate lock scope body if present
    if (!lock.scope_body.empty()) {
        writeLine("{");
        indent();
        writeLine(lock.scope_body);
        dedent();
        writeLine("}");
        writeLine("// Lock automatically released here (RAII)");
    }
}

void RustCodeGenerator::generateAtomicOperations(const AtomicInfo& atomic) {
    std::stringstream ss;

    writeLine("// Atomic variable: " + atomic.atomic_var_name);

    // Generate atomic variable if we have type info
    if (atomic.value_type) {
        std::string atomic_type;
        if (atomic.value_type->name == "int" || atomic.value_type->name == "int32_t") {
            atomic_type = "AtomicI32";
        } else if (atomic.value_type->name == "long" || atomic.value_type->name == "int64_t") {
            atomic_type = "AtomicI64";
        } else if (atomic.value_type->name == "bool") {
            atomic_type = "AtomicBool";
        } else {
            atomic_type = "AtomicUsize";
        }

        ss << "let " << sanitizeName(atomic.atomic_var_name)
           << " = std::sync::atomic::" << atomic_type << "::new(0);";
        writeLine(ss.str());
    }

    // Generate atomic operations
    for (const auto& op : atomic.operations) {
        ss.str("");
        ss << "// Atomic operation: " << op;
        writeLine(ss.str());

        if (op == "load") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".load(std::sync::atomic::Ordering::SeqCst);";
            writeLine(ss.str());
        } else if (op == "store") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".store(value, std::sync::atomic::Ordering::SeqCst);";
            writeLine(ss.str());
        } else if (op == "fetch_add") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".fetch_add(1, std::sync::atomic::Ordering::SeqCst);";
            writeLine(ss.str());
        } else if (op == "fetch_sub") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".fetch_sub(1, std::sync::atomic::Ordering::SeqCst);";
            writeLine(ss.str());
        } else if (op == "exchange") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".swap(new_value, std::sync::atomic::Ordering::SeqCst);";
            writeLine(ss.str());
        } else if (op == "compare_exchange_weak" || op == "compare_exchange_strong") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".compare_exchange(current, new_value, "
               << "std::sync::atomic::Ordering::SeqCst, "
               << "std::sync::atomic::Ordering::SeqCst);";
            writeLine(ss.str());
        }
    }
}

void RustCodeGenerator::generateConditionVariable(const ConditionVariableInfo& cv) {
    std::stringstream ss;

    writeLine("// Condition variable: " + cv.cv_var_name);
    ss << "let " << sanitizeName(cv.cv_var_name) << " = std::sync::Condvar::new();";
    writeLine(ss.str());

    if (!cv.associated_mutex.empty()) {
        writeLine("// Associated with mutex: " + cv.associated_mutex);
    }

    // Generate wait/notify operations
    for (const auto& op : cv.wait_conditions) {
        ss.str("");
        ss << "// Condition variable operation: " << op;
        writeLine(ss.str());

        if (op == "wait") {
            writeLine("let _guard = " + sanitizeName(cv.cv_var_name) +
                     ".wait(guard).unwrap();");
        } else if (op == "notify_one") {
            writeLine(sanitizeName(cv.cv_var_name) + ".notify_one();");
        } else if (op == "notify_all") {
            writeLine(sanitizeName(cv.cv_var_name) + ".notify_all();");
        } else if (op == "wait_for" || op == "wait_until") {
            writeLine("// " + op + " - use wait_timeout in Rust");
            writeLine("let (_guard, _timeout) = " + sanitizeName(cv.cv_var_name) +
                     ".wait_timeout(guard, Duration::from_secs(1)).unwrap();");
        }
    }
}

void RustCodeGenerator::generateAsyncFunction(const Function& func) {
    std::stringstream sig;

    // Generate async function signature
    sig << "pub async fn " << sanitizeName(func.name);

    // Add generic parameters for template functions
    if (func.is_template && !func.template_parameters.empty()) {
        sig << convertTemplateParametersToRust(func.template_parameters);
    }

    sig << "(";

    // Add self parameter for methods
    if (!func.is_static && !func.is_constructor) {
        if (func.is_const) {
            sig << "&self";
        } else {
            sig << "&mut self";
        }

        if (!func.parameters.empty()) {
            sig << ", ";
        }
    }

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << ": " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type
    if (func.return_type->kind != TypeKind::Void) {
        sig << " -> " << convertType(func.return_type);
    }

    writeLine(sig.str() + " {");
    indent();

    // Generate coroutine body
    if (func.coroutine_info.is_coroutine) {
        generateCoroutineBody(func);
    } else if (!func.async_tasks.empty()) {
        // Generate async task spawning
        for (const auto& task : func.async_tasks) {
            generateAsyncTask(task);
        }
    } else if (!func.futures.empty()) {
        // Generate future handling
        for (const auto& future : func.futures) {
            generateFuture(future);
        }
    } else if (!func.body.empty()) {
        writeLine("// Async function body:");
        writeLine(func.body);
    } else {
        writeLine("todo!()");
    }

    dedent();
    writeLine("}");
}

void RustCodeGenerator::generateCoroutineBody(const Function& func) {
    const auto& coro_info = func.coroutine_info;

    writeLine("// Converted from C++20 coroutine");
    writeLine("");

    if (coro_info.is_generator) {
        writeLine("// Generator function (uses co_yield)");
        writeLine("// Note: Consider using async streams or futures::stream::Stream");
    }

    // Generate body with async operations
    for (const auto& async_op : coro_info.async_operations) {
        generateAwaitExpression(async_op);
    }

    // Generate original function body if present
    if (!func.body.empty()) {
        writeLine("");
        writeLine("// Original function body:");
        writeLine(func.body);
    }
}

void RustCodeGenerator::generateAwaitExpression(const AsyncOperation& op) {
    std::stringstream ss;

    switch (op.op_type) {
        case AsyncOpType::CoAwait:
            writeLine("// co_await converted to .await");
            ss << "let result = " << op.expression << ".await;";
            writeLine(ss.str());
            break;

        case AsyncOpType::CoReturn:
            writeLine("// co_return converted to return");
            if (!op.expression.empty()) {
                ss << "return " << op.expression << ";";
            } else {
                ss << "return;";
            }
            writeLine(ss.str());
            break;

        case AsyncOpType::CoYield:
            writeLine("// co_yield converted to yield (via Stream)");
            writeLine("// Note: Rust async functions don't directly support yield");
            writeLine("// Consider using futures::stream::Stream trait");
            ss << "// yield " << op.expression << ";";
            writeLine(ss.str());
            break;
    }
}

void RustCodeGenerator::generateAsyncTask(const AsyncTaskInfo& task) {
    std::stringstream ss;

    writeLine("// Async task: " + task.task_var_name);

    if (!task.task_var_name.empty()) {
        // Assigned to a variable
        ss << "let " << sanitizeName(task.task_var_name)
           << " = tokio::spawn(async move {";
        writeLine(ss.str());
        indent();

        // Call the async function
        ss.str("");
        ss << sanitizeName(task.async_function_name) << "(";
        for (size_t i = 0; i < task.arguments.size(); ++i) {
            ss << task.arguments[i];
            if (i < task.arguments.size() - 1) {
                ss << ", ";
            }
        }
        ss << ").await";
        writeLine(ss.str());

        dedent();
        writeLine("});");

        if (!task.detached) {
            writeLine("");
            writeLine("// Await task completion");
            writeLine(sanitizeName(task.task_var_name) + ".await.unwrap();");
        }
    } else {
        // Detached task
        ss << "tokio::spawn(async move {";
        writeLine(ss.str());
        indent();

        ss.str("");
        ss << sanitizeName(task.async_function_name) << "(";
        for (size_t i = 0; i < task.arguments.size(); ++i) {
            ss << task.arguments[i];
            if (i < task.arguments.size() - 1) {
                ss << ", ";
            }
        }
        ss << ").await";
        writeLine(ss.str());

        dedent();
        writeLine("});");
    }

    writeLine("");
}

void RustCodeGenerator::generateFuture(const FutureInfo& future) {
    std::stringstream ss;

    writeLine("// Future: " + future.future_var_name);

    if (!future.promise_var_name.empty()) {
        // Create a oneshot channel (promise/future pair)
        ss << "let (" << sanitizeName(future.promise_var_name)
           << ", " << sanitizeName(future.future_var_name)
           << ") = futures::channel::oneshot::channel::<"
           << convertType(future.value_type) << ">();";
        writeLine(ss.str());
    } else {
        // Just a future variable
        ss << "// Future variable: " << future.future_var_name;
        writeLine(ss.str());
        ss.str("");
        ss << "// Use .await to get the value";
        writeLine(ss.str());
    }

    writeLine("");
}

void RustCodeGenerator::generateTraitImplementations(const ClassDecl& class_decl) {
    writeLine("// Trait implementations for inherited base classes");
    writeLine("");

    for (const auto& base_class_name : class_decl.base_classes) {
        generateTraitForBaseClass(base_class_name, class_decl);
        writeLine("");
    }
}

void RustCodeGenerator::generateTraitForBaseClass(const std::string& base_class_name, const ClassDecl& derived_class) {
    // Generate trait definition based on base class name
    std::string trait_name = sanitizeName(base_class_name);
    // Capitalize first letter for trait name (Rust convention)
    if (!trait_name.empty()) {
        trait_name[0] = std::toupper(trait_name[0]);
    }

    writeLine("// Trait representing C++ base class: " + base_class_name);
    writeLine("pub trait " + trait_name + " {");
    indent();

    // Extract public virtual methods to define trait interface
    bool has_virtual_methods = false;
    for (const auto& method : derived_class.methods) {
        if (method.is_virtual && !method.is_constructor && !method.is_destructor) {
            has_virtual_methods = true;

            // Generate trait method signature
            std::stringstream sig;
            sig << "fn " << sanitizeName(method.name) << "(";

            // Add self parameter
            if (method.is_const) {
                sig << "&self";
            } else {
                sig << "&mut self";
            }

            // Add other parameters
            for (size_t i = 0; i < method.parameters.size(); ++i) {
                const auto& param = method.parameters[i];
                sig << ", " << sanitizeName(param.name) << ": " << convertType(param.type);
            }

            sig << ")";

            // Return type
            if (method.return_type && method.return_type->kind != TypeKind::Void) {
                sig << " -> " << convertType(method.return_type);
            }

            sig << ";";
            writeLine(sig.str());
        }
    }

    // If no virtual methods found, add a placeholder
    if (!has_virtual_methods) {
        writeLine("// No virtual methods found in derived class");
        writeLine("// Add base class methods here as needed");
    }

    dedent();
    writeLine("}");
    writeLine("");

    // Generate trait implementation for the derived class
    std::string struct_name = sanitizeName(derived_class.name);
    writeLine("impl " + trait_name + " for " + struct_name + " {");
    indent();

    // Implement virtual methods
    for (const auto& method : derived_class.methods) {
        if (method.is_virtual && !method.is_constructor && !method.is_destructor) {
            std::stringstream sig;
            sig << "fn " << sanitizeName(method.name) << "(";

            // Add self parameter
            if (method.is_const) {
                sig << "&self";
            } else {
                sig << "&mut self";
            }

            // Add other parameters
            for (size_t i = 0; i < method.parameters.size(); ++i) {
                const auto& param = method.parameters[i];
                sig << ", " << sanitizeName(param.name) << ": " << convertType(param.type);
            }

            sig << ")";

            // Return type
            if (method.return_type && method.return_type->kind != TypeKind::Void) {
                sig << " -> " << convertType(method.return_type);
            }

            writeLine(sig.str() + " {");
            indent();

            if (!method.body.empty()) {
                writeLine("// Method body:");
                writeLine(method.body);
            } else {
                writeLine("// TODO: Implement method");
                writeLine("todo!()");
            }

            dedent();
            writeLine("}");
            writeLine("");
        }
    }

    // If no virtual methods, add placeholder
    if (!has_virtual_methods) {
        writeLine("// No methods to implement");
    }

    dedent();
    writeLine("}");
}

} // namespace hybrid
