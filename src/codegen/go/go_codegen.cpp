#include "codegen.h"
#include <algorithm>
#include <cctype>

namespace hybrid {

std::string GoCodeGenerator::generate(const IR& ir) {
    output_.str("");
    output_.clear();

    // Generate file header
    writeLine("// Auto-generated Go code from C++ source");
    writeLine("// Generated by Hybrid Transpiler");
    writeLine("");
    writeLine("package main");
    writeLine("");

    // Generate imports if needed
    bool needs_imports = false;
    for (const auto& class_decl : ir.getClasses()) {
        for (const auto& field : class_decl.fields) {
            if (field.type->name.find("sync") != std::string::npos) {
                needs_imports = true;
                break;
            }
        }
    }

    if (needs_imports) {
        writeLine("import (");
        indent();
        writeLine("\"sync\"");
        dedent();
        writeLine(")");
        writeLine("");
    }

    // Generate classes/structs
    for (const auto& class_decl : ir.getClasses()) {
        generateClass(class_decl);
        writeLine("");
    }

    // Generate standalone functions
    for (const auto& func : ir.getFunctions()) {
        generateFunction(func);
        writeLine("");
    }

    // Generate global variables
    for (const auto& var : ir.getGlobalVariables()) {
        generateVariable(var);
    }

    return output_.str();
}

void GoCodeGenerator::generateClass(const ClassDecl& class_decl) {
    // Generate struct definition
    std::string struct_name = capitalize(sanitizeName(class_decl.name));
    writeLine("type " + struct_name + " struct {");
    indent();

    for (const auto& field : class_decl.fields) {
        std::string field_name = capitalize(sanitizeName(field.name));
        std::string field_type = convertType(field.type);

        writeLine(field_name + " " + field_type);
    }

    dedent();
    writeLine("}");
    writeLine("");

    // Generate constructor function
    if (!class_decl.methods.empty()) {
        // Find constructor or generate New function
        bool has_constructor = false;
        for (const auto& method : class_decl.methods) {
            if (method.is_constructor) {
                has_constructor = true;

                std::stringstream sig;
                sig << "func New" << struct_name << "(";

                for (size_t i = 0; i < method.parameters.size(); ++i) {
                    const auto& param = method.parameters[i];
                    sig << sanitizeName(param.name) << " " << convertType(param.type);

                    if (i < method.parameters.size() - 1) {
                        sig << ", ";
                    }
                }

                sig << ") *" << struct_name << " {";
                writeLine(sig.str());
                indent();
                writeLine("return &" + struct_name + "{");
                indent();

                // Initialize fields
                for (const auto& field : class_decl.fields) {
                    std::string field_name = capitalize(sanitizeName(field.name));
                    writeLine(field_name + ": " + field_name + ",");
                }

                dedent();
                writeLine("}");
                dedent();
                writeLine("}");
                writeLine("");
                break;
            }
        }

        // Generate methods
        for (const auto& method : class_decl.methods) {
            if (!method.is_constructor && !method.is_destructor) {
                generateFunction(method, struct_name);
                writeLine("");
            }
        }
    }

    // Note about inheritance
    if (!class_decl.base_classes.empty()) {
        writeLine("// Note: C++ inheritance converted to interface embedding");
        for (const auto& base : class_decl.base_classes) {
            writeLine("// TODO: Implement interface for base class: " + base);
        }
        writeLine("");
    }
}

void GoCodeGenerator::generateFunction(const Function& func, const std::string& receiver_type) {
    // If function is async or coroutine, use async generation
    if (func.is_async || func.coroutine_info.is_coroutine) {
        generateAsyncFunction(func);
        return;
    }

    std::stringstream sig;

    sig << "func ";

    // Add receiver for methods
    if (!receiver_type.empty()) {
        std::string receiver_name = "this";
        if (func.is_const) {
            sig << "(" << receiver_name << " *" << receiver_type << ") ";
        } else {
            sig << "(" << receiver_name << " *" << receiver_type << ") ";
        }
    }

    // Function name
    std::string func_name = capitalize(sanitizeName(func.name));
    sig << func_name << "(";

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << " " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type - add error if function may throw
    if (func.may_throw) {
        // Function may throw - convert to multiple return values
        if (func.return_type->kind != TypeKind::Void) {
            sig << " (" << convertType(func.return_type) << ", error)";
        } else {
            sig << " error";
        }
    } else if (func.return_type->kind != TypeKind::Void) {
        sig << " " << convertType(func.return_type);
    }

    writeLine(sig.str() + " {");
    indent();

    // Function body with threading conversion
    if (func.uses_threading) {
        generateThreadingCode(func);
    }
    // Function body with exception handling conversion
    else if (!func.try_catch_blocks.empty()) {
        // Convert try-catch blocks to Go error handling
        generateTryCatchAsError(func);
    } else if (!func.body.empty()) {
        // Regular function body
        if (func.may_throw) {
            writeLine("// Function may throw - return error on failure");
        }
        writeLine("// TODO: Implement function body");
        writeLine(func.body);

        if (func.may_throw && func.return_type->kind != TypeKind::Void) {
            writeLine("// return result, nil");
        } else if (func.may_throw) {
            writeLine("return nil");
        }
    } else {
        if (func.may_throw) {
            writeLine("return nil");
        } else {
            writeLine("panic(\"not implemented\")");
        }
    }

    dedent();
    writeLine("}");
}

void GoCodeGenerator::generateTryCatchAsError(const Function& func) {
    // Convert C++ try-catch to Go error handling with defer/recover
    writeLine("// Converted from C++ try-catch block");

    for (const auto& block : func.try_catch_blocks) {
        // Use defer/recover for exception handling
        if (!block.catch_clauses.empty()) {
            writeLine("defer func() {");
            indent();
            writeLine("if r := recover(); r != nil {");
            indent();

            for (const auto& catch_clause : block.catch_clauses) {
                writeLine("// Catch " + catch_clause.exception_type);

                if (catch_clause.exception_type == "...") {
                    writeLine("// Catch-all handler");
                } else {
                    writeLine("// Handle specific exception type: " + catch_clause.exception_type);
                }

                if (!catch_clause.handler_body.empty()) {
                    writeLine(catch_clause.handler_body);
                }
            }

            dedent();
            writeLine("}");
            dedent();
            writeLine("}()");
            writeLine("");
        }

        // Generate try block body
        writeLine("// Try block:");
        if (!block.try_body.empty()) {
            writeLine(block.try_body);
        }

        if (func.may_throw && func.return_type->kind != TypeKind::Void) {
            writeLine("// return result, nil");
        } else if (func.may_throw) {
            writeLine("// return nil");
        }
    }
}

void GoCodeGenerator::generateVariable(const Variable& var) {
    std::string var_name = capitalize(sanitizeName(var.name));
    std::string var_type = convertType(var.type);

    std::stringstream line;
    line << "var " << var_name << " " << var_type;

    if (!var.initializer.empty()) {
        line << " = " << var.initializer;
    }

    writeLine(line.str());
}

std::string GoCodeGenerator::convertType(const std::shared_ptr<Type>& type) {
    if (!type) return "interface{}";

    switch (type->kind) {
        case TypeKind::Void:
            return ""; // Go doesn't have void, just no return type

        case TypeKind::Bool:
            return "bool";

        case TypeKind::Integer:
            // Map C++ integer types to Go
            if (type->name == "int" || type->name == "int32_t") return "int32";
            if (type->name == "long" || type->name == "int64_t") return "int64";
            if (type->name == "short" || type->name == "int16_t") return "int16";
            if (type->name == "char" || type->name == "int8_t") return "int8";
            if (type->name == "unsigned int" || type->name == "uint32_t") return "uint32";
            if (type->name == "unsigned long" || type->name == "uint64_t") return "uint64";
            if (type->name == "unsigned short" || type->name == "uint16_t") return "uint16";
            if (type->name == "unsigned char" || type->name == "uint8_t") return "uint8";
            if (type->name == "size_t") return "uint";
            return "int32"; // default

        case TypeKind::Float:
            if (type->name == "float") return "float32";
            if (type->name == "double") return "float64";
            return "float64"; // default

        case TypeKind::Pointer:
            // Smart pointers become slices or direct values in Go
            if (type->name.find("unique_ptr") != std::string::npos) {
                return "*" + convertType(type->element_type);
            }
            if (type->name.find("shared_ptr") != std::string::npos) {
                return "*" + convertType(type->element_type);
            }
            // Array pointer becomes slice
            if (type->element_type && type->element_type->kind == TypeKind::Array) {
                return "[]" + convertType(type->element_type->element_type);
            }
            return "*" + convertType(type->element_type);

        case TypeKind::Reference:
            // References become pointers in Go
            return "*" + convertType(type->element_type);

        case TypeKind::Array:
            return "[]" + convertType(type->element_type);

        // STL Container types
        case TypeKind::StdVector:
        case TypeKind::StdList:
        case TypeKind::StdDeque:
            if (!type->template_args.empty()) {
                return "[]" + convertType(type->template_args[0]);
            }
            return "[]interface{}";

        case TypeKind::StdMap:
        case TypeKind::StdUnorderedMap:
            if (type->template_args.size() >= 2) {
                return "map[" + convertType(type->template_args[0]) + "]" +
                       convertType(type->template_args[1]);
            }
            return "map[interface{}]interface{}";

        case TypeKind::StdSet:
        case TypeKind::StdUnorderedSet:
            // Go doesn't have built-in set, use map[T]bool
            if (!type->template_args.empty()) {
                return "map[" + convertType(type->template_args[0]) + "]bool";
            }
            return "map[interface{}]bool";

        case TypeKind::StdString:
            return "string";

        case TypeKind::StdPair:
            // Go doesn't have tuples, use anonymous struct
            if (type->template_args.size() >= 2) {
                return "struct { First " + convertType(type->template_args[0]) +
                       "; Second " + convertType(type->template_args[1]) + " }";
            }
            return "struct { First interface{}; Second interface{} }";

        case TypeKind::StdOptional:
            // Go uses pointer for optional
            if (!type->template_args.empty()) {
                return "*" + convertType(type->template_args[0]);
            }
            return "*interface{}";

        // Threading types
        case TypeKind::StdThread:
            return "/* goroutine (no type representation) */";

        case TypeKind::StdMutex:
        case TypeKind::StdRecursiveMutex:
            return "sync.Mutex";

        case TypeKind::StdSharedMutex:
            return "sync.RWMutex";

        case TypeKind::StdConditionVariable:
            return "sync.Cond";

        case TypeKind::StdAtomic:
            if (!type->template_args.empty()) {
                std::string inner_type = type->template_args[0]->name;
                if (inner_type == "int" || inner_type == "int32_t") return "atomic.Int32";
                if (inner_type == "long" || inner_type == "int64_t") return "atomic.Int64";
                if (inner_type == "unsigned int" || inner_type == "uint32_t") return "atomic.Uint32";
                if (inner_type == "unsigned long" || inner_type == "uint64_t") return "atomic.Uint64";
                if (inner_type == "bool") return "atomic.Bool";
            }
            return "atomic.Value";

        case TypeKind::StdLockGuard:
        case TypeKind::StdUniqueLock:
        case TypeKind::StdSharedLock:
            return "/* defer unlock pattern */";

        // Async/Coroutine types
        case TypeKind::StdFuture:
        case TypeKind::StdAsync:
        case TypeKind::Task:
            if (!type->template_args.empty()) {
                return "chan " + convertType(type->template_args[0]);
            }
            return "chan interface{}";

        case TypeKind::StdPromise:
            if (!type->template_args.empty()) {
                return "chan<- " + convertType(type->template_args[0]);
            }
            return "chan<- interface{}";

        case TypeKind::Coroutine:
            // Coroutine as channel iterator
            if (!type->template_args.empty()) {
                return "<-chan " + convertType(type->template_args[0]);
            }
            return "<-chan interface{}";

        case TypeKind::Struct:
        case TypeKind::Class:
            return capitalize(sanitizeName(type->name));

        default:
            return "interface{} /* Unknown type: " + type->name + " */";
    }
}

std::string GoCodeGenerator::sanitizeName(const std::string& name) {
    std::string result = name;

    // Handle Go keywords
    static const std::vector<std::string> keywords = {
        "break", "case", "chan", "const", "continue", "default", "defer",
        "else", "fallthrough", "for", "func", "go", "goto", "if", "import",
        "interface", "map", "package", "range", "return", "select", "struct",
        "switch", "type", "var"
    };

    if (std::find(keywords.begin(), keywords.end(), result) != keywords.end()) {
        result = result + "_";
    }

    return result;
}

std::string GoCodeGenerator::capitalize(const std::string& name) {
    if (name.empty()) return name;

    std::string result = name;
    result[0] = std::toupper(result[0]);
    return result;
}

void GoCodeGenerator::generateThreadingCode(const Function& func) {
    writeLine("// Threading code converted from C++");
    writeLine("");

    // If threads are created, we need sync.WaitGroup
    if (!func.threads_created.empty()) {
        writeLine("var wg sync.WaitGroup");
        writeLine("");
    }

    // Generate goroutine creation
    for (const auto& thread : func.threads_created) {
        generateGoroutineCreation(thread);
        writeLine("");
    }

    // Generate mutex locks
    for (const auto& lock : func.lock_scopes) {
        generateMutexLock(lock);
        writeLine("");
    }

    // Generate atomic operations
    for (const auto& atomic : func.atomic_operations) {
        generateAtomicOperations(atomic);
        writeLine("");
    }

    // Generate condition variable operations
    for (const auto& cv : func.condition_variables) {
        generateConditionVariable(cv);
        writeLine("");
    }

    // Generate original function body
    if (!func.body.empty()) {
        writeLine("// Original function body:");
        writeLine(func.body);
    }

    // Wait for all goroutines if they are joinable
    bool has_joinable_threads = false;
    for (const auto& thread : func.threads_created) {
        if (thread.joinable && !thread.detached) {
            has_joinable_threads = true;
            break;
        }
    }

    if (has_joinable_threads) {
        writeLine("");
        writeLine("// Wait for all goroutines to complete");
        writeLine("wg.Wait()");
    }
}

void GoCodeGenerator::generateGoroutineCreation(const ThreadInfo& thread) {
    std::stringstream ss;

    writeLine("// Goroutine: " + thread.thread_var_name);

    if (thread.joinable && !thread.detached) {
        writeLine("wg.Add(1)");
    }

    // Generate goroutine launch
    writeLine("go func() {");
    indent();

    if (thread.joinable && !thread.detached) {
        writeLine("defer wg.Done()");
    }

    // Call the thread function with arguments
    ss << capitalize(sanitizeName(thread.function_name)) << "(";

    for (size_t i = 0; i < thread.arguments.size(); ++i) {
        ss << thread.arguments[i];
        if (i < thread.arguments.size() - 1) {
            ss << ", ";
        }
    }

    ss << ")";
    writeLine(ss.str());

    dedent();
    writeLine("}()");

    if (thread.detached) {
        writeLine("// Note: Original thread was detached (goroutine runs independently)");
    }
}

void GoCodeGenerator::generateMutexLock(const LockInfo& lock) {
    std::stringstream ss;

    switch (lock.type) {
        case LockInfo::LockGuard:
        case LockInfo::UniqueLock:
            writeLine("// Mutex lock with defer unlock (RAII pattern)");
            ss << sanitizeName(lock.mutex_name) << ".Lock()";
            writeLine(ss.str());
            ss.str("");
            ss << "defer " << sanitizeName(lock.mutex_name) << ".Unlock()";
            writeLine(ss.str());
            break;

        case LockInfo::SharedLock:
            writeLine("// Read lock with defer unlock");
            ss << sanitizeName(lock.mutex_name) << ".RLock()";
            writeLine(ss.str());
            ss.str("");
            ss << "defer " << sanitizeName(lock.mutex_name) << ".RUnlock()";
            writeLine(ss.str());
            break;

        default:
            writeLine("// Unknown lock type");
            break;
    }

    // Generate lock scope body if present
    if (!lock.scope_body.empty()) {
        writeLine("");
        writeLine("// Critical section:");
        writeLine("{");
        indent();
        writeLine(lock.scope_body);
        dedent();
        writeLine("}");
        writeLine("// Mutex automatically unlocked via defer");
    }
}

void GoCodeGenerator::generateAtomicOperations(const AtomicInfo& atomic) {
    std::stringstream ss;

    writeLine("// Atomic variable: " + atomic.atomic_var_name);

    // Generate atomic variable if we have type info
    if (atomic.value_type) {
        std::string atomic_type;
        if (atomic.value_type->name == "int" || atomic.value_type->name == "int32_t") {
            atomic_type = "atomic.Int32";
        } else if (atomic.value_type->name == "long" || atomic.value_type->name == "int64_t") {
            atomic_type = "atomic.Int64";
        } else if (atomic.value_type->name == "bool") {
            atomic_type = "atomic.Bool";
        } else if (atomic.value_type->name == "unsigned int" || atomic.value_type->name == "uint32_t") {
            atomic_type = "atomic.Uint32";
        } else if (atomic.value_type->name == "unsigned long" || atomic.value_type->name == "uint64_t") {
            atomic_type = "atomic.Uint64";
        } else {
            atomic_type = "atomic.Value";
        }

        ss << "var " << sanitizeName(atomic.atomic_var_name) << " " << atomic_type;
        writeLine(ss.str());
    }

    // Generate atomic operations
    for (const auto& op : atomic.operations) {
        ss.str("");
        ss << "// Atomic operation: " << op;
        writeLine(ss.str());

        if (op == "load") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name) << ".Load()";
            writeLine(ss.str());
        } else if (op == "store") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name) << ".Store(value)";
            writeLine(ss.str());
        } else if (op == "fetch_add") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name) << ".Add(1)";
            writeLine(ss.str());
        } else if (op == "fetch_sub") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name) << ".Add(-1)";
            writeLine(ss.str());
        } else if (op == "exchange") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name) << ".Swap(newValue)";
            writeLine(ss.str());
        } else if (op == "compare_exchange_weak" || op == "compare_exchange_strong") {
            ss.str("");
            ss << sanitizeName(atomic.atomic_var_name)
               << ".CompareAndSwap(old, new)";
            writeLine(ss.str());
        }
    }
}

void GoCodeGenerator::generateConditionVariable(const ConditionVariableInfo& cv) {
    std::stringstream ss;

    writeLine("// Condition variable: " + cv.cv_var_name);

    if (!cv.associated_mutex.empty()) {
        ss << sanitizeName(cv.cv_var_name) << " := sync.NewCond(&"
           << sanitizeName(cv.associated_mutex) << ")";
        writeLine(ss.str());
    } else {
        writeLine("// Note: Condition variable requires associated mutex");
        ss << "var mutex sync.Mutex";
        writeLine(ss.str());
        ss.str("");
        ss << sanitizeName(cv.cv_var_name) << " := sync.NewCond(&mutex)";
        writeLine(ss.str());
    }

    // Generate wait/signal operations
    for (const auto& op : cv.wait_conditions) {
        ss.str("");
        ss << "// Condition variable operation: " << op;
        writeLine(ss.str());

        if (op == "wait") {
            writeLine(sanitizeName(cv.cv_var_name) + ".Wait()");
        } else if (op == "notify_one") {
            writeLine(sanitizeName(cv.cv_var_name) + ".Signal()");
        } else if (op == "notify_all") {
            writeLine(sanitizeName(cv.cv_var_name) + ".Broadcast()");
        } else if (op == "wait_for" || op == "wait_until") {
            writeLine("// " + op + " - Go doesn't have timed wait on Cond");
            writeLine("// Use channels or time.After for timeout behavior");
        }
    }
}

void GoCodeGenerator::generateAsyncFunction(const Function& func) {
    std::stringstream sig;

    // Generate function signature that returns a channel
    sig << "func ";

    // Function name
    std::string func_name = capitalize(sanitizeName(func.name));
    sig << func_name << "(";

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << " " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type - channel for async result
    if (func.return_type->kind != TypeKind::Void) {
        sig << " <-chan " << convertType(func.return_type);
    } else {
        sig << " <-chan struct{}";
    }

    writeLine(sig.str() + " {");
    indent();

    // Create result channel
    if (func.return_type->kind != TypeKind::Void) {
        writeLine("resultChan := make(chan " + convertType(func.return_type) + ", 1)");
    } else {
        writeLine("resultChan := make(chan struct{}, 1)");
    }
    writeLine("");

    // Launch goroutine
    writeLine("go func() {");
    indent();
    writeLine("defer close(resultChan)");
    writeLine("");

    // Generate coroutine body
    if (func.coroutine_info.is_coroutine) {
        generateCoroutineAsGoroutine(func);
    } else if (!func.async_tasks.empty()) {
        // Generate async task spawning
        for (const auto& task : func.async_tasks) {
            generateAsyncTask(task);
        }
    } else if (!func.body.empty()) {
        writeLine("// Async function body:");
        writeLine(func.body);
    }

    // Send result
    if (func.return_type->kind != TypeKind::Void) {
        writeLine("");
        writeLine("// Send result to channel");
        writeLine("resultChan <- result");
    } else {
        writeLine("");
        writeLine("// Signal completion");
        writeLine("resultChan <- struct{}{}");
    }

    dedent();
    writeLine("}()");
    writeLine("");
    writeLine("return resultChan");

    dedent();
    writeLine("}");
}

void GoCodeGenerator::generateCoroutineAsGoroutine(const Function& func) {
    const auto& coro_info = func.coroutine_info;

    writeLine("// Converted from C++20 coroutine");
    writeLine("");

    if (coro_info.is_generator) {
        writeLine("// Generator function (uses co_yield)");
        writeLine("// Note: Use channel to yield values");
    }

    // Generate body with async operations converted to channel operations
    for (const auto& async_op : coro_info.async_operations) {
        generateChannelOperation(async_op);
    }

    // Generate original function body if present
    if (!func.body.empty()) {
        writeLine("");
        writeLine("// Original function body:");
        writeLine(func.body);
    }
}

void GoCodeGenerator::generateChannelOperation(const AsyncOperation& op) {
    std::stringstream ss;

    switch (op.op_type) {
        case AsyncOpType::CoAwait:
            writeLine("// co_await converted to channel receive");
            ss << "result := <-" << op.expression;
            writeLine(ss.str());
            break;

        case AsyncOpType::CoReturn:
            writeLine("// co_return converted to return");
            if (!op.expression.empty()) {
                ss << "result = " << op.expression;
                writeLine(ss.str());
            }
            writeLine("return");
            break;

        case AsyncOpType::CoYield:
            writeLine("// co_yield converted to channel send");
            writeLine("// Note: For generators, use a separate yield channel");
            ss << "// yieldChan <- " << op.expression;
            writeLine(ss.str());
            break;
    }
}

void GoCodeGenerator::generateAsyncTask(const AsyncTaskInfo& task) {
    std::stringstream ss;

    writeLine("// Async task: " + task.task_var_name);

    if (!task.task_var_name.empty()) {
        // Assigned to a variable (returns channel)
        ss << sanitizeName(task.task_var_name) << " := "
           << capitalize(sanitizeName(task.async_function_name)) << "(";

        for (size_t i = 0; i < task.arguments.size(); ++i) {
            ss << task.arguments[i];
            if (i < task.arguments.size() - 1) {
                ss << ", ";
            }
        }
        ss << ")";
        writeLine(ss.str());

        if (!task.detached) {
            writeLine("");
            writeLine("// Wait for task completion");
            writeLine("<-" + sanitizeName(task.task_var_name));
        }
    } else {
        // Detached task (fire and forget)
        writeLine("go func() {");
        indent();

        ss << capitalize(sanitizeName(task.async_function_name)) << "(";
        for (size_t i = 0; i < task.arguments.size(); ++i) {
            ss << task.arguments[i];
            if (i < task.arguments.size() - 1) {
                ss << ", ";
            }
        }
        ss << ")";
        writeLine(ss.str());

        dedent();
        writeLine("}()");
    }

    writeLine("");
}

} // namespace hybrid
