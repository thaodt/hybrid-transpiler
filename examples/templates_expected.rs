// Auto-generated Rust code from C++ templates
// Generated by Hybrid Transpiler

/**
 * Example 1: Simple template class -> Generic struct
 */
pub struct Box<T> {
    value: T,
}

impl<T> Box<T> {
    pub fn new(v: T) -> Self {
        Self { value: v }
    }

    pub fn get(&self) -> T
    where
        T: Clone,
    {
        self.value.clone()
    }

    pub fn set(&mut self, v: T) {
        self.value = v;
    }
}

/**
 * Example 2: Template function -> Generic function
 */
pub fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

/**
 * Example 3: Multiple template parameters
 */
pub struct Pair<K, V> {
    key: K,
    value: V,
}

impl<K, V> Pair<K, V> {
    pub fn new(k: K, v: V) -> Self {
        Self { key: k, value: v }
    }

    pub fn get_key(&self) -> &K {
        &self.key
    }

    pub fn get_value(&self) -> &V {
        &self.value
    }
}

/**
 * Example 4: Non-type template parameters -> Const generics
 */
pub struct Array<T, const N: usize> {
    data: [T; N],
}

impl<T, const N: usize> Array<T, const N: usize>
where
    T: Default + Copy,
{
    pub fn size(&self) -> usize {
        N
    }

    pub fn get(&self, index: usize) -> Option<&T> {
        self.data.get(index)
    }
}

/**
 * Example 7: Template class with template methods
 */
pub struct SmartContainer<T> {
    data: Vec<T>,
}

impl<T> SmartContainer<T> {
    pub fn add(&mut self, item: T) {
        self.data.push(item);
    }

    pub fn sum_as<U>(&self) -> U
    where
        T: Clone + Into<U>,
        U: Default + std::ops::AddAssign,
    {
        let mut sum = U::default();
        for item in &self.data {
            sum += item.clone().into();
        }
        sum
    }

    pub fn size(&self) -> usize {
        self.data.len()
    }
}

/**
 * Example 9: Template specialization -> Trait implementation
 */
pub trait Serializer<T> {
    fn serialize(value: &T) -> String;
}

// Generic implementation
pub struct GenericSerializer;

impl<T: std::fmt::Debug> Serializer<T> for GenericSerializer {
    fn serialize(value: &T) -> String {
        format!("{:?}", value)
    }
}

// Specialized for i32
pub struct IntSerializer;

impl Serializer<i32> for IntSerializer {
    fn serialize(value: &i32) -> String {
        value.to_string()
    }
}

/**
 * Example 10: Matrix with const generics
 */
pub struct Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

impl<T, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS>
where
    T: Default + Copy,
{
    pub fn rows(&self) -> usize {
        ROWS
    }

    pub fn cols(&self) -> usize {
        COLS
    }

    pub fn at(&self, r: usize, c: usize) -> Option<&T> {
        self.data.get(r).and_then(|row| row.get(c))
    }
}

/**
 * Example 11: Template alias -> Type alias
 */
pub type Vec<T> = std::vec::Vec<T>;
pub type SharedPtr<T> = std::rc::Rc<T>;

/**
 * Example 13: Template with constraints
 */
pub fn add<T>(a: T, b: T) -> T
where
    T: std::ops::Add<Output = T>,
{
    a + b
}

fn main() {
    // Example 1: Box
    let int_box = Box::new(42);
    let str_box = Box::new(String::from("Hello"));

    // Example 2: max function
    let max_int = max(10, 20);
    let max_double = max(3.14, 2.71);

    // Example 3: Pair
    let pair = Pair::new(String::from("age"), 25);

    // Example 4: Array with size
    let arr: Array<i32, 5> = Array {
        data: [0; 5],
    };

    // Example 7: SmartContainer
    let mut container = SmartContainer { data: Vec::new() };
    container.add(1);
    container.add(2);
    container.add(3);
    let sum: f64 = container.sum_as();

    // Example 10: Matrix
    let matrix: Matrix<f64, 3, 3> = Matrix {
        data: [[0.0; 3]; 3],
    };
}
