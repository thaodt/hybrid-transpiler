// Auto-generated Go code from C++ source
// Generated by Hybrid Transpiler

package main

import (
	"fmt"
	"time"
)

// Example 1: Simple async function
func SimpleAsyncFunction() <-chan struct{} {
	resultChan := make(chan struct{}, 1)

	go func() {
		defer close(resultChan)

		// Converted from C++20 coroutine

		fmt.Println("Starting async operation...")

		// Simulate async work
		time.Sleep(100 * time.Millisecond)

		fmt.Println("Async operation completed!")

		// Signal completion
		resultChan <- struct{}{}
	}()

	return resultChan
}

// Example 2: Async function with return value
func ComputeAsync(x, y int32) <-chan int32 {
	resultChan := make(chan int32, 1)

	go func() {
		defer close(resultChan)

		// Converted from C++20 coroutine

		// Simulate computation
		time.Sleep(50 * time.Millisecond)

		result := x + y

		// Send result to channel
		resultChan <- result
	}()

	return resultChan
}

func ChainedAsync(value int32) <-chan int32 {
	resultChan := make(chan int32, 1)

	go func() {
		defer close(resultChan)

		// Converted from C++20 coroutine

		fmt.Println("Starting chained async...")

		// co_await converted to channel receive
		result1 := <-ComputeAsync(value, 10)
		// co_await converted to channel receive
		result2 := <-ComputeAsync(result1, 20)

		// Send result to channel
		resultChan <- result2
	}()

	return resultChan
}

// Example 3: Generator using channel
func RangeGenerator(start, end int32) <-chan int32 {
	ch := make(chan int32)

	go func() {
		defer close(ch)

		// Converted from C++20 coroutine
		// Generator function (uses co_yield)
		// Note: Use channel to yield values

		for i := start; i < end; i++ {
			// co_yield converted to channel send
			ch <- i
		}
	}()

	return ch
}

// Example 4: Async calculator using goroutines
type AsyncCalculator struct{}

func NewAsyncCalculator() *AsyncCalculator {
	return &AsyncCalculator{}
}

func (this *AsyncCalculator) PerformCalculation(a, b int32) int32 {
	// Create channels for results
	result1Chan := make(chan int32, 1)
	result2Chan := make(chan int32, 1)

	// Launch goroutine 1
	go func() {
		defer close(result1Chan)
		time.Sleep(100 * time.Millisecond)
		result1Chan <- a * 2
	}()

	// Launch goroutine 2
	go func() {
		defer close(result2Chan)
		time.Sleep(100 * time.Millisecond)
		result2Chan <- b * 3
	}()

	// Wait for results
	result1 := <-result1Chan
	result2 := <-result2Chan

	return result1 + result2
}

func (this *AsyncCalculator) FireAndForget(value int32) {
	// Detached goroutine
	go func() {
		fmt.Printf("Processing: %d\n", value)
	}()
}

// Example 5: Promise/Future using channel
type DataFetcher struct {
	dataPromise chan<- string
	dataFuture  <-chan string
}

func NewDataFetcher() *DataFetcher {
	ch := make(chan string, 1)
	return &DataFetcher{
		dataPromise: ch,
		dataFuture:  ch,
	}
}

func (this *DataFetcher) FetchDataAsync() {
	go func() {
		// Simulate network request
		time.Sleep(200 * time.Millisecond)

		// Fulfill promise
		this.dataPromise <- "Fetched data!"
		close(this.dataPromise)
	}()
}

func (this *DataFetcher) GetData() string {
	// Wait for data
	return <-this.dataFuture
}

func main() {
	// Example 1: Simple coroutine
	<-SimpleAsyncFunction()

	// Example 2: Chained async
	chainResult := <-ChainedAsync(5)
	fmt.Printf("Chained result: %d\n", chainResult)

	// Example 3: Generator
	gen := RangeGenerator(0, 5)
	for value := range gen {
		fmt.Printf("Generated: %d\n", value)
	}

	// Example 4: Async calculator
	calc := NewAsyncCalculator()
	result := calc.PerformCalculation(10, 20)
	fmt.Printf("Calculation result: %d\n", result)

	calc.FireAndForget(42)

	// Example 5: Promise/Future
	fetcher := NewDataFetcher()
	fetcher.FetchDataAsync()
	data := fetcher.GetData()
	fmt.Printf("Fetched: %s\n", data)
}
