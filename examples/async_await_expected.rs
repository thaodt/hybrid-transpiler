// Auto-generated Rust code from C++ source
// Generated by Hybrid Transpiler

use tokio;
use futures::channel::oneshot;
use futures::stream::Stream;

// Example 1: Simple async function
pub async fn simple_async_function() {
    // Converted from C++20 coroutine

    println!("Starting async operation...");

    // Simulate async work
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    println!("Async operation completed!");
    // co_return converted to return
    return;
}

// Example 2: Async function with return value
pub async fn compute_async(x: i32, y: i32) -> i32 {
    // Converted from C++20 coroutine

    // Simulate computation
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

    let result = x + y;

    // co_return converted to return
    return result;
}

pub async fn chained_async(value: i32) -> i32 {
    // Converted from C++20 coroutine

    println!("Starting chained async...");

    // co_await converted to .await
    let result1 = compute_async(value, 10).await;
    // co_await converted to .await
    let result2 = compute_async(result1, 20).await;

    // co_return converted to return
    return result2;
}

// Example 3: Generator (Stream in Rust)
pub fn range_generator(start: i32, end: i32) -> impl Stream<Item = i32> {
    // Converted from C++20 coroutine
    // Generator function (uses co_yield)
    // Note: Consider using async streams or futures::stream::Stream

    async_stream::stream! {
        for i in start..end {
            // co_yield converted to yield (via Stream)
            yield i;
        }
    }
}

// Example 4: Async calculator using tokio::spawn
pub struct AsyncCalculator {}

impl AsyncCalculator {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn perform_calculation(&self, a: i32, b: i32) -> i32 {
        // Async task: future1
        let future1 = tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            a * 2
        });

        // Async task: future2
        let future2 = tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            b * 3
        });

        // Await task completion
        let result1 = future1.await.unwrap();
        let result2 = future2.await.unwrap();

        result1 + result2
    }

    pub fn fire_and_forget(&self, value: i32) {
        // Async task (detached)
        tokio::spawn(async move {
            println!("Processing: {}", value);
        });
    }
}

// Example 5: Promise/Future using oneshot channel
pub struct DataFetcher {
    data_promise: Option<oneshot::Sender<String>>,
    data_future: oneshot::Receiver<String>,
}

impl DataFetcher {
    pub fn new() -> Self {
        let (data_promise, data_future) = oneshot::channel::<String>();
        Self {
            data_promise: Some(data_promise),
            data_future,
        }
    }

    pub fn fetch_data_async(&mut self) {
        let promise = self.data_promise.take().unwrap();

        tokio::spawn(async move {
            // Simulate network request
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

            // Fulfill promise
            promise.send("Fetched data!".to_string()).ok();
        });
    }

    pub async fn get_data(self) -> String {
        // Wait for data
        self.data_future.await.unwrap()
    }
}

#[tokio::main]
async fn main() {
    // Example 1: Simple coroutine
    simple_async_function().await;

    // Example 2: Chained async
    let chain_result = chained_async(5).await;
    println!("Chained result: {}", chain_result);

    // Example 3: Generator (Stream)
    use futures::stream::StreamExt;
    let mut gen = range_generator(0, 5);
    while let Some(value) = gen.next().await {
        println!("Generated: {}", value);
    }

    // Example 4: std::async
    let calc = AsyncCalculator::new();
    let result = calc.perform_calculation(10, 20).await;
    println!("Calculation result: {}", result);

    calc.fire_and_forget(42);

    // Example 5: Promise/Future
    let mut fetcher = DataFetcher::new();
    fetcher.fetch_data_async();
    let data = fetcher.get_data().await;
    println!("Fetched: {}", data);
}
